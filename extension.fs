( STACK MANIPULATION )
: nip >r drop r> ;          ( n1 n2 -- n2 )
: swap over >r nip r> ;     ( n1 n2 -- n2 n1 ) 
: tuck swap over ;          ( n1 n2 -- n2 n1 n2 )
: rot >r swap r> swap ;     ( n1 n2 n3 -- n2 n3 n1 )
: r r> r> dup >r swap >r ;  ( -- r )

: -rot swap >r swap r> ;    ( n1 n2 n3 -- n3 n1 n2 )
: ?dup if -> then dup ;     ( n -- n ? )
: 2drop drop drop ;         ( n1 n2 -- )
: 2nip >r nip nip r> ;      ( n1 n2 n3 n4 -- n3 n4 )
: 2dup over over ;          ( n1 n2 -- n1 n2 n1 n2 )
: 2swap >r -rot r> -rot ;   ( n1 n2 n3 n4 -- n3 n4 n1 n2 )

: 2over >r >r 2dup r> -rot r> -rot ;    ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 )
: 2tuck ( ... ) ;                       ( n1 n2 n3 n4 -- n3 n4 n1 n2 n3 n4 )
: third >r >r dup r> swap r> swap ;     ( n1 n2 n3 -- n1 n2 n3 n1 )
: fourth >r >r >r dup r> swap 
         r> swap r> swap ;              ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 )

( ALTERNATIVES )
( : nip >r drop r> ; )
( : nip over xor xor ; )
( : swap >r a! r> a ; )
( : tuck a! >r a r> a ; )
( : rot >r >r a! r> r> a ; )
( : r r> r> a! >r >r a ; )

( COMPARISON )
: < - -if drop 0 -> then drop -1 ;          ( n1 n2 -- f )
: = - if -> then drop 1 ;                   ( n1 n2 -- f )
: > swap - -if drop 0 -> then drop -1 ;     ( n1 n2 -- f )
: 0< -if drop 0 -> then drop -1 ;           ( n -- f )
: 0= if -> then drop -1 ;                   ( n -- f )
: 0> negate -if drop 0 -> then drop -1 ;    ( n -- f )

( ARITHMETIC AND LOGICAL )
: - inv + 1 + ;                                             ( n1 n2 -- diff )
: 1+ 1 + ;                                                  ( n -- n+1 )
: 1- -1 + ;                                                 ( n -- n-1 )
: 2+ 2 + ;                                                  ( n -- n+2 )
: 2- -2 + ;                                                 ( n -- n-2 )
: * -if >r negate a! r> negate a swap then a! 0
    !< >r a if drop drop r> -> then drop r> +* <- ;         ( n1 n2 -- prod )
: / a! 0 !< >r -if drop r> 1- -> then a - r> 1+ <- ;        ( n1 n2 -- quot )
: mod swap !< over - -if + -> then <- ;                     ( n1 n2 -- rem )
( : mod a! !< dup >r a - -if drop r> -> then r> drop <- ; )
: /mod over over mod rot rot / ;                            ( n1 n2 -- rem quot )
: */mod >r * r> /mod ;                                      ( n1 n2 n3 -- rem quot )
: */ >r * r> / ;                                            ( n1 n2 n3 -- quot )
: max over over < if drop nip -> then drop drop ;           ( n1 n2 -- max )
: min over over > if drop nip -> then drop drop ;           ( n1 n2 -- min )
: abs    -if inv 1 + ;                                      ( n -- |n| )
: negate     inv 1 + ;                                      ( n -- -n )
: or over over and >r xor r> + ;                            ( n1 n2 -- or )

( MEMORY )
: ?  @ . ;                                                  ( -- )
: +! @ + ! ;                                                ( n -- )
: move 1- for swap a! a 1+ swap @ swap a! ! a 1+ next ;     ( addr dest u -- )
: fill >r if drop r> drop -> then 1- r> dup !+ <- ;         ( u byte -- )
: erase 1- for 0 !+ next ;                                  ( u -- )
: dump if drop cr -> then cr a . 58 .e space
       @+ dup . space .e 1- <- ;                            ( u -- )

( CONTROL STRUCTURES )
: exit r> drop -2 >r ; ( -- )

( TERMINAL INPUT-OUTPUT )
: cr 10 .e ;                            ( -- )
: emit .e ;                             ( char -- )
: space 32 .e ;                         ( -- )
: spaces if drop -> then 1- 32 .e <- ;  ( u -- )
: page 64 for cr next ;                 ( -- )
: type if drop -> then 1- @+ .e <- ;    ( u -- )
: .r for space next . ;                 ( n u -- )
: .s >r >r >r >r space dup . space r> dup . space
	 r> dup . space r> dup . space r> dup . space
; ( -- )
