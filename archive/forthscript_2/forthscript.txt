P		Program counter.
A		General purpose read-write register.
B		Write-only register.
T		Top word of a data stack.
S		Second word of a data stack.
R		Return stack

Jump Instructions
:		Define a new word (followed by its name).
->		Exit current word definition.
<-		Jump to beggining of current word.
name	Call. Fetch word and run.
unext	If R is zero, pop the return stack and continue to next opcode. If R is
        nonzero, decrement R and jump to slot 0 of the current word.
next	If R is zero, pop the return stack and continue to next opcode. If R is
        non-zero, decrement R and jump to preceding 'for' word.
if		Jump to 'then' if zero.
-if		Jump to 'then' if not negative.

Memory Instructions
@p		Fetch-P. Pushes data stack, reads [P] into T, and increments P.
@+		Fetch-plus. Pushes data stack, reads [A] into T, increments A.
@b		Fetch-B. Pushes data stack, reads [B] into T.
@		Fetch. Pushes data stack, reads [A] into T.
!p		Store-P. Write T into [P], pops the data stack, and increments P.
!+		Store-plus. Write T into [A], pops the data stack, and increment A.
!b		Store-B. Write T into [B], pops the data stack.
!		Store. Writes T into [A], pops the data stack.

ALU Instructions
+*      Multiply step. Signed multiplicand is in S, unsigned multiplier in A,
        T = 0 at start of a step sequence. If bit A0 not zero, set T = T + S.
        
2*		Shift stack left.
2/		Shift stack right.
inv		NOT to stack.
+		Add to stack.
and		AND to stack.
xor		XOR to stack.

Stack Instructions
drop	Pop the data stack, dropping T.
dup		Fetch T and push onto the data stack.
r>		Push R onto the data stack, dropping R.
over	Load 2nd datum onto the data stack.
a		Fetches A onto T, pushing the data stack.
nop		Do nothing. Spends time.
>r		Push T onto the return stack, dropping T.
b!		B-store. Stores T into register B, pops the data stack.
a!		A-store. Stores T into register A, pops the data stack.

Miscellaneous Instructions
(		Begin comment, terminated by ')'.

ADDITIONS
for		Push P into R then push T into R, pops the data stack.
        : for r> dup >r swap >r >r ;
swap    Exchange values at S and T.
        : swap over >r >r drop r> r> ;

here	Push to data stack the current @p - 1
        : here r> dup >r -1 + ;
r       Push to top of stack value of R.
        : r r> r> dup >r swap >r ;

*       Multiplication (

Input output Instructions
emit	Type ASCII character from stack.
key		Read key, put ASCII value on stack.
.s		Display stack.
.       Display and pop top of stack.

: rot >r swap r> swap ;
: -rot rot rot ;
: -> -2 r> drop >r ;
: <- -1 r> drop >r ;
