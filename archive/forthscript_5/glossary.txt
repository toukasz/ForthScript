Jumps   Memory  ALU     Stack   REG     Misc

;       @b      +*      drop    p       .n
->      @+      2*      dup     a       .c
<-      @       2/      over    p!      (
if      !b      inv     >r      a!
-if     !+      +       r>      b!
        !       and     nop
                xor
















P		program counter
R		return stack
A		read-write register.
B		write-only register.
T		top value of a data stack.
S		second value of a data stack.


Opcode  Notes
:       define, terminated by ';'
->      jump to '>!'
<-      jump to '!<'
if      jump to 'then' if T=0
-if     jump to 'then' if Tâ‰¥0

@b      fetch via B
@+      fetch via A (autoincrement A)
@       fetch via A
!b      store via B
!+      store via A (autoincrement A)
!       store via A

+*      multiply step
2*      left shift
2/      right shift (signed)
+       add

inv     invert all bits
and     bitwise and
xor     bitwise xor

drop    pop T
dupe    push T
over    push S
r>      pop R push T
>r      pop T push R

p       fetch from program counter
a       fetch from register A
p!      store into program counter
a!      store into register A
b!      store into register B

.n		type T as decimal
.e		type T as ASCII character

(		comment, terminated by ')'



Jump Instructions
:		Define. Followed by its name; closed by ';'.
->		Jump-ahead. Goto next '>!'.
<-		Jump-back. Goto previous '!<'.
name	Call. Fetch word and run.
next	Next. If R is zero, pop the return stack and continue
        to next opcode. If R is non-zero, decrement R and jump
        to preceding 'for' word.
if		Jump to 'then' if zero.
-if		Jump to 'then' if not negative.

Memory Instructions
@p		Fetch-P. Pushes data stack, reads [P] into T, and increments P.
@+		Fetch-plus. Pushes data stack, reads [A] into T, increments A.
@b		Fetch-B. Pushes data stack, reads [B] into T.
@		Fetch. Pushes data stack, reads [A] into T.
!p		Store-P. Write T into [P], pops the data stack, and increments P.
!+		Store-plus. Write T into [A], pops the data stack, and increment A.
!b		Store-B. Write T into [B], pops the data stack.
!		Store. Writes T into [A], pops the data stack.

ALU Instructions
+*      Multiply step. Signed multiplicand is in S, unsigned
        multiplier in A, T=0 at start of a step sequence. If
        bit A0 not zero, set T=T+S.
2*		Shift stack left.
2/		Shift stack right.
not		NOT to stack.
+		Add to stack.
and		AND to stack.
xor		XOR to stack.

Stack Instructions
drop	Pop the data stack, dropping T.
dup		Fetch T and push onto the data stack.
r>		Push R onto the data stack, dropping R.
over	Load 2nd datum onto the data stack.
a		Fetches A onto T, pushing the data stack.
nop		Do nothing. Spends time.
>r		Push T onto the return stack, dropping T.
b!		B-store. Stores T into register B, pops the data stack.
a!		A-store. Stores T into register A, pops the data stack.

Input output Instructions
.n		Type value from stack as decimal.
.e		Type ASCII character from stack.
key		Read key, put ASCII value on stack.

Miscellaneous Instructions
(		Begin comment, terminated by ')'.
bye		Terminate program.


[[ ADDITIONS ]]
Stack Instructions
swap    ( n -- n n )
		Reverse top two stack items.
        : swap over >r >r drop r> r> ;
rot		( n1 n2 n3 -- n2 n3 n1 )
		Rotate third item to top.
		: rot >r swap r> swap ;
nip		( n1 n2 -- n2 )
		Drop S from the data stack.
		: swap drop ;
tuck	( n1 n2 -- n2 n1 n2 )
		Duplicate T to below S.
2drop	( n1 n2 -- )
		Drop both T and S.
2dup	( n1 n2 -- n1 n2 n1 n2 )
		Duplicate both T and S to top of data stack.
-dup	( n -- n ? )
		Duplicate only if non-zero.
r		( -- n )
		Push to top of stack value of R.
        : r r> r> dup >r swap >r ;
-		( n1 n2 -- diff )
		Subtract (diff = n1 - n2).
*		( n1 n2 -- prod )
		Multiply.
/		( n1 n2 -- quot )
		Divide (quot = n1 / n2)
mod		( n1 n2 -- rem )
		Modulo (quot = n1 % n2)
/mod	( n1 n2 -- rem quot )
		Divide, giving remainder and quotient.
max		( n1 n2 -- max )
		Maximum.
min		( n1 n2 -- min )
		Minimum.
abs		( n -- abs )
		Absolue value.
minus	( n -- -n )
		Change sign.
or		( n1 n2 -- xor )
		Logical bitwise OR.
<		( n1 n2 -- f )
		True if T < S.
>		( n1 n2 -- f )
		True if T > S.
=		( n1 n2 -- f )
		True if T equal to S.
0<		( n -- f )
		True if T is negative.
0=		( n -- f )
		True if T is zero.
true	( -- f )
		Push -1 to T.
false	( -- f )
		Push 0 to T.
1-		( n -- n-- )
		Decrement T by 1.
1+		( n -- n++ )
		Increment T by 1.

Input output Instructions
.		( n -- )
		Pop and print T.
.r		( n u -- )
		Pop and print T, right-justified in u column.
cr		( -- )
		Do a carriage return.
space	( -- )
		Type one space.
spaces	( u - )
		Type u spaces.
."		( -- )
		Print mussage (terminted by ").
dump	( addr u -- )
		Dump u numbers starting at address.
type	( addr u -- )
		Type u characters starting at address.
expect	( addr u )
		Read u charcters (or until carriage-return) from input device to address.

Memory and Dictionary Instructions
?		( -- )
		Print contents of address at A.
move	( from to u -- )
		Move u bytes in memory.
fill	( addr u b -- )
		fill u bytes in memory with b.
erase	( addr u -- )
		Fill u bytes in memory with zeros.
forget	( -- )
		Delete following word.
words	( -- )
		Show all words.

Miscellaneous Instructions
@d		( -- n )
		Return size/length of the data stack.
abort	( -- )
		Empty the data stack and return stack.

for		Push P into R then push T into R, pops the data stack.
        : for r> dup >r swap >r >r ;

here	Push to data stack the current @p - 1
        : here r> dup >r -1 + ;
